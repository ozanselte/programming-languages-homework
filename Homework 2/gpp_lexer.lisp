(defun reader (filename)
    (with-open-file (stream filename)
        (setf contents (make-string (file-length stream)))
        (read-sequence contents stream)
        contents
    )
)

(defun is-op (str next)
    (cond
        ((string= str "+") "OP_PLUS")
        ((string= str "-") "OP_MINUS")
        ((string= str "/") "OP_DIV")
        ((string= str "(") "OP_OP")
        ((string= str ")") "OP_CP")
        ((string= str "\"") "OP_OC")
        ((string= str ",") "OP_COMMA")
        ((string= str "**") "OP_DBMULT")
        ((and (string= str "*") (string/= next "*")) "OP_MULT")
        (T NIL)
    )
)

(defun is-keyword (str)
    (setf s (string-downcase str))
    (cond
        ((string= s "and") "KW_AND")
        ((string= s "or") "KW_OR")
        ((string= s "not") "KW_NOT")
        ((string= s "equal") "KW_EQUAL")
        ((string= s "less") "KW_LESS")
        ((string= s "nil") "KW_NIL")
        ((string= s "list") "KW_LIST")
        ((string= s "append") "KW_APPEND")
        ((string= s "concat") "KW_CONCAT")
        ((string= s "set") "KW_SET")
        ((string= s "deffun") "KW_DEFFUN")
        ((string= s "for") "KW_FOR")
        ((string= s "if") "KW_IF")
        ((string= s "exit") "KW_EXIT")
        ((string= s "load") "KW_LOAD")
        ((string= s "disp") "KW_DISP")
        ((string= s "true") "KW_TRUE")
        ((string= s "false") "KW_FALSE")
        (T NIL)
    )
)

(defun is-alpha (str)
    (setf c (char str 0))
    (alpha-char-p c)
)

(defun is-num (str)
    (setf c (char str 0))
    (not (null (digit-char-p c)))
)

(defun is-alphanum (str)
    (or (is-alpha str) (is-num str))
)

(defun is-white (str)
    (setf c (char str 0))
    (or (char= c #\SPACE) (char= c #\RETURN)
        (char= c #\NEWLINE) (char= c #\TAB))
)

(defun dfa (str next state)
    (setf lens (length str))
    (setf lasts (subseq str (1- lens) lens))
    (case state
        ('s-strt
            (cond
                ((is-white str)
                    (setf str "")
                )
                ((string= str ";")
                    (setf state 's-smcl)
                )
                ((string= str "0")
                    (cond
                        ((and (not (null next)) (is-alphanum next))
                            (setf state 's-eror)
                        )
                        (T
                            (write-line "VALUE")
                            (setf str "")
                        )
                    )
                )
                ((is-num str)
                    (setf state 's-valu)
                )
                ((is-alpha str)
                    (setf state 's-idtf)
                )
                ((is-op str next)
                    (write-line (is-op str next))
                    (setf str "")
                )
                ((string= str "*")
                    (setf state 's-mult)
                )
                (T(setf state 's-eror))
            )
        )
        ('s-smcl
            (if (string= ";;" str)
                (setf state 's-cmnt)
                (setf state 's-eror)
            )
        )
        ('s-cmnt
            (setf lastc (char lasts 0))
            (when (char= lastc #\NEWLINE)
                (setf state 's-strt)
                (write-line "COMMENT")
                (setf str "")
            )
        )
        ('s-mult
            (when (is-op str next)
                (setf state 's-strt)
                (write-line (is-op str next))
                (setf str "")
            )
        )
        ('s-valu
            (cond
                ((is-white lasts)
                    (setf state 's-strt)
                    (write-line "VALUE")
                    (setf str "")
                )
                ((is-op lasts NIL)
                    (setf state 's-strt)
                    (write-line "VALUE")
                    (setf temp (dfa lasts next state))
                    (setf str (car temp))
                    (setf state (nth 1 temp))
                )
                ((not (is-num lasts))
                    (setf state 's-eror)
                )
            )
        )
        ('s-idtf
            (setf imp (subseq str 0 (1- lens)))
            (cond
                ((is-white lasts)
                    (setf state 's-strt)
                    (if (is-keyword imp)
                        (write-line (is-keyword imp))
                        (write-line "IDENTIFIER")
                    )
                    (setf str lasts)
                )
                ((is-op lasts NIL)
                    (setf state 's-strt)
                    (if (is-keyword imp)
                        (write-line (is-keyword imp))
                        (write-line "IDENTIFIER")
                    )
                    (setf temp (dfa lasts next state))
                    (setf str (car temp))
                    (setf state (nth 1 temp))
                )
                ((not (is-alphanum lasts))
                    (setf state 's-eror)
                )
            )
        )
    )
    (list str state)
)

(defun lexer (content &optional prev state)
    (when (null prev) (setf prev ""))
    (when (null state) (setf state 's-strt))
    (setf lenc (length content))
    (when (= 0 lenc)
        (dfa (concatenate 'string prev " ") NIL state)
        (return-from lexer NIL)
    )
    (setf c (subseq content 0 1))
    (if (= 1 lenc)
        (setf cnext NIL)
        (setf cnext (subseq content 1 2))
    )
    (setf str (concatenate 'string prev c))
    (setf temp (dfa str cnext state))
    (setf state (nth 1 temp))
    (when (eq state 's-eror)
        (when (string= (subseq str 0 1) "0")
            (setf str (concatenate 'string str (subseq content 1 2)))
        )
        (format T "SYNTAX_ERROR ~A cannot be tokenized." str)
        (bye)
    )
    (setf str (string-left-trim " " (car temp)))
    (lexer (subseq content 1 lenc) str state)
)

(defun gppinterpreter (&optional filename)
    (when (not (null filename))
        (setf content (reader filename))
        (lexer content)
    )
    (lexer (read-line))
    (gppinterpreter)
)

(defun main ()
    (if (null *args*)
        (gppinterpreter)
        (gppinterpreter (car *args*))
    )
)

(main)