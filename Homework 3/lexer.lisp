(defun reader (filename)
    (with-open-file (stream filename)
        (setf contents (make-string (file-length stream)))
        (read-sequence contents stream)
        contents
    )
)

(defun is-op (str next)
    (cond
        ((string= str "+") 'OP_PLUS)
        ((string= str "-") 'OP_MINUS)
        ((string= str "/") 'OP_DIV)
        ((string= str "(") 'OP_OP)
        ((string= str ")") 'OP_CP)
        ((string= str ",") 'OP_COMMA)
        ((string= str "**") 'OP_DBMULT)
        ((and (string= str "*") (string/= next "*")) 'OP_MULT)
        (T NIL)
    )
)

(defun is-keyword (str)
    (setf s (string-downcase str))
    (cond
        ((string= s "and") 'KW_AND)
        ((string= s "or") 'KW_OR)
        ((string= s "not") 'KW_NOT)
        ((string= s "equal") 'KW_EQUAL)
        ((string= s "less") 'KW_LESS)
        ((string= s "nil") 'KW_NIL)
        ((string= s "list") 'KW_LIST)
        ((string= s "append") 'KW_APPEND)
        ((string= s "concat") 'KW_CONCAT)
        ((string= s "set") 'KW_SET)
        ((string= s "deffun") 'KW_DEFFUN)
        ((string= s "for") 'KW_FOR)
        ((string= s "if") 'KW_IF)
        ((string= s "exit") 'KW_EXIT)
        ((string= s "load") 'KW_LOAD)
        ((string= s "disp") 'KW_DISP)
        ((string= s "true") 'KW_TRUE)
        ((string= s "false") 'KW_FALSE)
        (T NIL)
    )
)

(defun is-alpha (str)
    (setf c (char str 0))
    (alpha-char-p c)
)

(defun is-num (str)
    (setf c (char str 0))
    (not (null (digit-char-p c)))
)

(defun is-alphanum (str)
    (or (is-alpha str) (is-num str))
)

(defun is-white (str)
    (setf c (char str 0))
    (or (char= c #\SPACE) (char= c #\RETURN)
        (char= c #\NEWLINE) (char= c #\TAB))
)

(defun dfa (str next state &optional token)
    (when (null token)
        (setf token '())
    )
    (setf lens (length str))
    (setf lasts (subseq str (1- lens) lens))
    (case state
        ('s-strt
            (cond
                ((is-white str)
                    (setf str "")
                )
                ((string= str ";")
                    (setf state 's-smcl)
                )
                ((string= str "0")
                    (cond
                        ((and (not (null next)) (is-alphanum next))
                            (setf state 's-eror)
                        )
                        (T
                            (setf token (append token (list 'VALUE)))
                            (setf str "")
                        )
                    )
                )
                ((is-num str)
                    (setf state 's-valu)
                )
                ((is-alpha str)
                    (setf state 's-idtf)
                )
                ((is-op str next)
                    (setf token (append token (list (is-op str next))))
                    (setf str "")
                )
                ((string= str "*")
                    (setf state 's-mult)
                )
                ((string= str "\"")
                    (setf state 's-strn)
                )
                (T(dolist
                    (setf state 's-eror)
                ))
            )
        )
        ('s-strn
            (setf lastc (char lasts 0))
            (when (char= lastc #\")
                (setf state 's-strt)
                (setf token (append token (list 'STRING (subseq str 1 (1- lens)))))
                (setf str "")
            )
        )
        ('s-smcl
            (if (string= ";;" str)
                (setf state 's-cmnt)
                (dolist
                    (setf state 's-eror)
                )
            )
        )
        ('s-cmnt
            (setf lastc (char lasts 0))
            (when (or (char= lastc #\NEWLINE) (char= lastc #\RETURN))
                (setf state 's-strt)
                (setf token (append token (list 'COMMENT)))
                (setf str "")
            )
        )
        ('s-mult
            (when (is-op str next)
                (setf state 's-strt)
                (setf token (append token (list (is-op str next))))
                (setf str "")
            )
        )
        ('s-valu
            (setf imp (subseq str 0 (1- lens)))
            (cond
                ((is-white lasts)
                    (setf state 's-strt)
                    (setf token (append token (list 'VALUE (parse-integer imp))))
                    (setf str "")
                )
                ((is-op lasts NIL)
                    (setf state 's-strt)
                    (setf token (append token (list 'VALUE (parse-integer imp))))
                    (setf temp (dfa lasts next state))
                    (setf str (car temp))
                    (setf state (nth 1 temp))
                    (setf token (append token (nth 2 temp)))
                )
                ((not (is-num lasts))
                    (setf state 's-eror)
                )
            )
        )
        ('s-idtf
            (setf imp (subseq str 0 (1- lens)))
            (cond
                ((is-white lasts)
                    (setf state 's-strt)
                    (if (is-keyword imp)
                        (setf token (append token (list (is-keyword imp))))
                        (setf token (append token (list 'IDENTIFIER imp)))
                    )
                    (setf str lasts)
                )
                ((is-op lasts NIL)
                    (setf state 's-strt)
                    (if (is-keyword imp)
                        (setf token (append token (list (is-keyword imp))))
                        (setf token (append token (list 'IDENTIFIER imp)))
                    )
                    (setf temp (dfa lasts next state))
                    (setf str (car temp))
                    (setf state (nth 1 temp))
                    (setf token (append token (nth 2 temp)))
                )
                ((not (is-alphanum lasts))
                    (setf state 's-eror)
                )
            )
        )
    )
    (list str state token)
)

(defun token-merge (tokens token)
    (when (/= (list-length token) 0)
        (when (car token)
            (setf tokens (append tokens (list (car token))))
        )
        (setf tokens (token-merge tokens (cdr token)))
    )
    tokens
)

(defun lexer (content tokens &optional prev state)
    (when (null prev) (setf prev ""))
    (when (null state) (setf state 's-strt))
    (setf lenc (length content))
    (when (= 0 lenc)
        (dfa (concatenate 'string prev " ") NIL state)
        (return-from lexer tokens)
    )
    (setf c (subseq content 0 1))
    (if (= 1 lenc)
        (setf cnext NIL)
        (setf cnext (subseq content 1 2))
    )
    (setf str (concatenate 'string prev c))
    (setf temp (dfa str cnext state))
    (setf state (nth 1 temp))
    (when (eq state 's-eror)
        (when (string= (subseq str 0 1) "0")
            (setf str (concatenate 'string str (subseq content 1 2)))
        )
        (format T "SYNTAX_ERROR ~A cannot be tokenized." str)
        (bye)
    )
    (setf str (string-left-trim " " (car temp)))
    (setf token (nth 2 temp))
    (setf tokens (token-merge tokens token))
    (lexer (subseq content 1 lenc) tokens str state)
)